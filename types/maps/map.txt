In Go, maps are implemented as hash tables that use a hashing function to compute 
the index of the underlying data structure where key-value pairs are stored. 
Maps are highly optimized for fast lookups, insertions, and deletions, making them 
efficient for managing key-value associations.

Memory Structure of Maps in Go:

    1. Buckets:
        A Go map consists of multiple buckets that hold key-value pairs. 
        When a key is inserted, Go uses a hashing function to compute which bucket 
        the key-value pair should go into. Each bucket can hold multiple key-value pairs 
        to handle collisions, i.e., situations where different keys produce the same hash value.
        If too many key-value pairs are stored in a single bucket (due to collisions), 
        Go dynamically allocates more buckets and rehashes the data.

    2. Hash Function:
        When a key is added to the map, Go computes the hash of the key to determine the bucket 
        where the key-value pair will be stored. This hash function provides a way to distribute 
        keys uniformly across buckets. The hash function is based on the key type, and the 
        bucket is determined using the lower bits of the hash.


    3. Overflow Buckets:
        If a bucket becomes too full (i.e., exceeds a certain load factor), the map will 
        allocate overflow buckets. These overflow buckets allow the map to continue storing 
        new key-value pairs without resizing the entire map immediately.
        As the map grows in size (due to more key-value pairs being inserted), Go dynamically 
        resizes the map to reduce the need for overflow buckets.


    4. Load Factor and Resizing:
        Maps in Go are designed to maintain efficient performance by keeping the number of elements per bucket relatively small. When the number of key-value pairs increases and exceeds the optimal load factor, Go triggers a rehashing process. This involves doubling the number of buckets and redistributing the existing key-value pairs across the new buckets.
        
    
    5. Pointers and Indirection:
        A Go map contains pointers to buckets, and each bucket can store multiple 
        key-value pairs. These key-value pairs are stored as arrays or lists inside 
        the bucket structure. When you retrieve a value from a map, Go uses the hash of 
        the key to determine which bucket the value resides in and then checks that bucket 
        for the exact key.


Memory Layout
    Here's an overview of how Go maps are stored in memory:

        Map header: The map itself is a reference type and contains metadata such as the number of 
        key-value pairs, number of buckets, and pointers to the buckets array.

        Buckets array: This array holds pointers to individual buckets, and each bucket contains 
        arrays of keys and values. Each bucket also contains pointers to overflow buckets if needed.

        Overflow handling: When buckets overflow, the map uses linked lists of overflow buckets. 
        Over time, if the map grows, it will resize and rehash the keys to distribute them across 
        a larger number of buckets.


you cannot use the copy function to copy a map in Go. The copy function is designed 
specifically for slices, not maps.